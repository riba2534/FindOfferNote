- 1.1 MySQL 逻辑架构

  - 逻辑架构

    ![image](https://image-1252109614.cos.ap-beijing.myqcloud.com/img/20200807113413.jpg)

    - 最上层服务并非MySQL独有，大多数 C/S 架构的工具都有类似架构

    - 第二层是服务器层，大多数MySQL核心服务功都在第二层，包括查询、解析、优化、缓存以及所有的内置函数（例如：日期，时间，数学和加密函数），所有的跨存储殷勤都在这一层实现：存储过程，触发器，视图等。

    - 第三层是MySQL的存储引擎。存储引擎负责MySQL中的数据存储和提取。每个存储引擎都有自己的优势和劣势。服务器通过API，与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异

  - 1.1.1 连接管理与安全性

    - 每个客户端都会在服务端有一个线程，这个连接的查询都会在这个单独的线程中进行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。

    - 客户端连接到MySQL服务器时，服务器会对它进行鉴权，验证该客户端是否有某个特定查询的权限。

  - 1.1.2 优化与执行

    - MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。

    - 优化器不关心表使用的是什么存储殷勤，但是存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量或者某个操作的具体开销信息，以及表数据的统计信息等。

    - 对于 SELECT 语句，在解析查询之前，服务器会先检查查询缓存，如果能直接找到对应查询，服务器就不必再进行查询解析、优化和执行的过程。

- 1.2 并发控制

  - 无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。

  - 1.2.1 读写锁

    - 两种锁的类型

      - 共享锁（shared lock）或者叫 读锁（read lock）

      - 排他锁（exclusive lock）或者叫 写锁（write lock）

    - 读锁是共享的，几个用户可以同时读取同一资源，互不干扰

    - 写锁是排他的，一个写锁会阻塞其他的读锁或写锁。只有这样，才能确保在给定时间里，只有一个用户能执行写入。只有这样才能确保数据一致性

  - 1.2.2 锁粒度

    - 提高共享资源的并发性的方式可以是让锁定对象更有选择性。尽量只锁定要修改的部分的数据，而不是所有资源。

    - 加锁也要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统开销。

    - MySQL提供的最重要的两种锁策略

      - 表锁（table lock）
        - MySQL中最基本的锁策略，并且使开销最小的策略。会锁定整张表，一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作

      - 行级锁（row lock）
        - 行级锁可以最大程度的支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而在MySQL服务器层没有实现。服务器层完全不了解存储引擎中的实现。

- 1.3 事务

  - 事务是一组原子性的SQL查询，是一个独立的工作单元。如果数据库引擎可以成功对该组执行所有查询语句，那么就执行该语句，如果其中有任何一条语句因为崩溃或者其他原因无法执行，则所有语句都不执行。「要么全部成功，要么全部失败」

  - 事物的ACID特性

    - 原子性（atomicity）
      - 一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作必须全部提交成功，或者全部失败回滚。

    - 一致性（consistency）
      - 数据库总是从一个一致性状态转换到另一个一致性状态。事务没有提交，则事务所造成的的修改也不会保存到数据库中。

    - 隔离性（isolation）
      - 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的

    - 持久性（durability）
      - 事务一单提交，则其所做的所有修改就会永久保存在数据库中。此时即使系统崩溃，修改的数据也不会丢失。

  - 1.3.1 隔离级别

    - 在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些是事务中可见的，哪些是在事务中不可见的。较低的级别隔离通常可以执行更高级的并发，系统的开销也更低

    - 四种隔离级别：

      - READ UNCOMMITTED（未提交读）

        - 事务中的修改，即使没有提交，对其他事务也都是可见的

        - 事务可以读取未提交数据，这也被称为 脏读（Dirty read）

        - 未提交读不会比其他级别好太多，但是缺乏其他级别的很多好处，实际应用中一般很少使用

      - READ COMMITTED（提交读）

        - 大多数数据库系统默认隔离级别都是这个。（但是MySQL不是）。

        - 一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也被称作「不可重复读」（nonrepeatable read）

      - REPEATABLE READ（可重复读）

        - 是MySQL的默认隔离级别

        - 解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。

        - 理论上，可重复读隔离级别还是无法解决幻读问题。

        - 幻读（Phantom Read）：某个事务在读取某个范围的记录时，另一个事务又在该范围内插入了一条新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom row）。InnoDB和XtraDb通过多版本并发控制，解决了幻读问题。

      - SERIALIZABLE（可串行化）

        - 最高的隔离级别，强制使事务串行执行，避免了前面所说的幻读问题。

        - 在读取的每一行数据加锁，可能导致大量超时和锁争用问题

        - 实际应用中很少用到，只要在非常需要确保数据一致性而且可以接受没有并发的情况下，考虑采用该级别。

      - 隔离级别对比![img](https://api2.mubu.com/v3/document_image/48e18b7a-c90b-4ceb-816c-6709385600a9-5127810.jpg)

  - 1.3.2 死锁

    - 死锁是指两个活多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

    - InnoDB目前处理死锁的方式是，将持有最少行级排他锁的事务进行回滚

    - 死锁产生的双重原因：

      - 有些是因为真正的数据冲突

      - 有些是完全因为存储引擎的实现方式所导致的

    - 死锁发生后，只有部分或者完全回滚一个事务，才能打破死锁。

  - 1.3.3 事务日志

    - 使用后，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在磁盘上的事务日志中，不用每次都将修改的数据本身持久到磁盘。

    - 日志采用追加方式，对于磁盘是顺序IO，而不是随机IO需要在磁盘的多个地方移动磁头。

    - 事务日志持久后，内存中修改的数据在后台可以慢慢刷回到磁盘。目前大多数存储引擎都是这么实现的

  - 1.3.4 MySQL中的事务

    - MySQL提供了两种事务型存储引擎：InnoDB和NDB Cluster。另外还有一些第三方存储引擎也支持事务，比如：XtraDB和PBXT

    - 自动提交（AUTOCOMMIT）

      - 默认使用自动提交模式，如果不是显式的开始一个事务，则每个查询都被当做一个事务执行提交操作。通过 `show variables like 'autocommit'` 命令可以查看当前有没有开启。

      - 设置MySQL隔离级别：

        - 设置整个库隔离级别：`SET TRANSACTION ISOLATION LEVEL`

        - 设置当前会话隔离级别：`SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED`

    - 在事务中混合使用存储引擎

      - 在同一个事务中，使用多种存储引擎是不可靠的。

      - 如果在事务中混用事务型和非事务型的表（如：InnoDB和MyISAM表），正常提交的情况下没问题。但是如果需要回滚，非事务型表的变更无法撤销。

    - 隐式锁定和显式锁定

      - InnoDB采用两段锁协议，在事务执行过程中，随时都可以执行锁定，锁只有在 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是同一时刻被释放

      - InnoDB会根据隔离级别在需要的时候自动加锁

      - InnoDB也支持特定的语句进行显式锁定，但是这些语句不属于SQL规范

        - SELECT ... LOCK IN SHARE MODE

        - SELECT ... FOR UPDATE

- 1.4 多版本并发控制

  - MySQL的大多数事务存储引擎实现的都不是简单的行级锁。一般都实现了多版本并发控制（MVCC）

  - 可以认为MVCC是行级锁的一个变种，大多实现了非阻塞的读操作，写操作也只是锁定必要的行。

  - MVCC的实现，是通过保存在某个时间点的快照来实现的。也就是说吗，不管需要执行多长时间，每个事务看到的数据是一致的。根据事务开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

  - 乐观并发控制

  - 悲观并发控制

  - MVCC 只在可重复读和提交读这两个隔离级别中工作。